#pragma once

class Scene
{
	friend class Window;
	friend class SceneManager;

protected:
	//継承以外生成禁止
	Scene() {}

	//オブジェクト生成
	GameObject* Instantiate();
	//オブジェクト生成(名前指定)
	GameObject* Instantiate(std::string _name);
	//オブジェクト生成(名前,テクスチャ指定)
	GameObject* Instantiate(std::string _name, const wchar_t* _texPath);
private:
	//シーンのロード処理（オブジェクトの生成）
	virtual void Load() {}
	//初期化処理（シーン遷移後に呼び出す）
	virtual void Init() {}
	//毎フレーム呼び出す
	virtual void Update() {}
	//かたずけ処理
	virtual void Uninit() {}
};


class SceneManager final
{
	friend class Window;

private:
	//生成禁止
	SceneManager() {}

	//最初のシーンの読み込み
	static void Init();
	//次へのシーンの切り替え
	static void NextScene();
public:
	//シーンの読み込み・切り替え(同期)
	template<typename T>
	static void LoadScene()
	{
		std::string sceneName = typeid(T).name();

		//非同期にシーンをロードしている場合
		if (async)
		{
			LOG("no loding %s,other scene loding now", sceneName.substr(6).c_str());
		}

		//シーンが登録済みかどうか
		auto it = m_sceneList.find(sceneName);
		if (it != m_sceneList.end()) {

			//新しいリストに変える
			RenderManager::GenerateList();
			ObjectManager::GenerateList();
			//対応したシーンのロード処理
			it->second.second();
			//シーン切り替え
			NextScene();
			
			LOG_NL;
			LOG("Now Switching to %s",sceneName.substr(6).c_str());
			return;
		}

		//シーンが見つからなかった場合
		LOG_WARNING("couldn't find the scene, so registered it.");
		RegisterScene<T>();
		LoadScene<T>();
	}

	//シーンの読み込み(非同期)
	template<typename T>
	static void LoadingScene()
	{
		//ロード中
		if (async) return;

		std::string sceneName = typeid(T).name();

		//シーンが登録されているか
		auto it = m_sceneList.find(sceneName);
		if (it != m_sceneList.end()) {
			async = true;
			loading = true;

			// Start scene loading asynchronously
			LOG_NL;
			LOG("Starting scene loading...%s", sceneName.substr(6).c_str());

			//スレッドを立てる
			std::future<void> sceneFuture = std::async(std::launch::async, [&]()
				{
					Box2D::WorldManager::ChengeNextWorld();
					RenderManager::ChangeNextRenderList();
					ObjectManager::ChangeNextObjectList();
					it->second.second();
				});
			//スレッドが終わるまでループさせる
			Window::WindowUpdate(sceneFuture, loading);

			return;
		}

		//シーンが登録されていなかった場合
		LOG_WARNING("couldn't find the scene, so registered it.");
		RegisterScene<T>();
		LoadingScene<T>();
	}

	//シーンの切り替え(ロードが終わってからじゃないと反映されない)
	static void ChangeScene()
	{
		//非同期でロードが終わっている場合
		if (async && !loading)
		{
			//シーンの切り替え
			NextScene();

			//ロードしておいたリストに切り替える
			RenderManager::LinkNextRenderList();

#ifdef WORLD_UPDATE_MULTITHERD
			Box2D::WorldManager::PauseWorldUpdate();
#endif
			ObjectManager::LinkNextObjectList();
			Box2D::WorldManager::LinkNextWorld();

#ifdef WORLD_UPDATE_MULTITHERD
			Box2D::WorldManager::ResumeWorldUpdate();
#endif
			async = false;

			LOG("Now Switching to the New Scene...");
		}
	}

	//シーンクラスをリストに登録する
	template<typename T>
	static void RegisterScene(int version = 1) {
		std::string sceneName = typeid(T).name();

		//シーンが既にある場合
		auto it = m_sceneList.find(sceneName);
		if (it != m_sceneList.end() && it->second.first == version)
		{
			LOG("%s is already registered.", sceneName.substr(6).c_str());
			return;
		}
			
		//ロード関数を作成
		std::function<void(void)> createFn = [&]()
			{
				m_nextScene.reset(new T());
				m_nextScene->Load();
			};

		//登録
		m_sceneList[sceneName] = make_pair(version, createFn);
	}

private:
	//シーンリスト
	static std::unordered_map<std::string, std::pair<int, std::function<void()>>> m_sceneList;
	//今のシーン
	static std::unique_ptr<Scene> m_currentScene;
	//次のシーン
	static std::unique_ptr<Scene> m_nextScene;
	//非同期用変数
	static bool async;
	static bool loading;
};
